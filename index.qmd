x---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

:::: {.callout-important}
## ðŸ“‹ What You Need To Do

- [ ] Fork and create repo `simulationChallenge` in your GitHub
- [ ] Clone locally and open in Cursor
- [ ] Write your analysis in this `index.qmd`
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/simulationChallenge/`
:::

:::: {.callout-warning}
## âš ï¸ AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain the results in your own words.  Verify cursor's calculations as investment simulation is tricky.
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

::::: {.callout-note}
## Grading Scope

- Sections 1â€“4: required and can earn up to 90% of the grade.
- Sections 5â€“6: optional; strong, well-supported work here can bring your score up to 100%.
::::

### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is >, =, or < $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?

```{python}
#| label: q1-expected-value-py
#| echo: false

# Compute EV after one flip in Python
# After one flip:
# - Heads (50% chance): W1 = 30,000 * 1.5 = $45,000
# - Tails (50% chance): W1 = 30,000 * 0.6 = $18,000
# EV = 0.5 * 45,000 + 0.5 * 18,000

initial_balance = 30000
heads_multiplier = 1.5
tails_multiplier = 0.6
prob_heads = 0.5

wealth_heads = initial_balance * heads_multiplier
wealth_tails = initial_balance * tails_multiplier
expected_value = (prob_heads * wealth_heads) + (prob_heads * wealth_tails)

print(f"Initial wealth: ${initial_balance:,}")
print(f"After heads (50%): ${wealth_heads:,}")
print(f"After tails (50%): ${wealth_tails:,}")
print(f"\nExpected value after one flip: ${expected_value:,.2f}")
print(f"Gain in EV: ${expected_value - initial_balance:,.2f}")
print(f"Percentage gain: {((expected_value - initial_balance) / initial_balance) * 100:.2f}%")
```

**Interpretation:** The expected value after one flip is **$31,500**, which is **5% higher** than the initial buy-in of $30,000. This simple expected value calculation suggests the game has a positive expected return, which is favorable for the investor. However, this is based ona single flip and does not account for the volatility of the game over time.

### 2) Single Simulation Over Time (Narrative + Plot)

Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance"

# Simulate one path from $30,000 over N periods
import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Assuming starting at age 46, playing until age 75 (75-46) = 29 flips
n_flips = 29
initial_balance = 30000

# Initialize array to store wealth over time
wealth_path = np.zeros(n_flips + 1)
wealth_path[0] = initial_balance

# Simulate the coin flips and compute wealth at each step
for t in range(1, n_flips + 1):
    coin_flip = np.random.random()  # Generate random number in [0, 1)
    if coin_flip < 0.5:
        # Heads: increase by 50%
        wealth_path[t] = wealth_path[t-1] * 1.5
    else:
        # Tails: decrease by 40%
        wealth_path[t] = wealth_path[t-1] * 0.6

# Create time series plot using object-oriented matplotlib
fig, ax = plt.subplots(figsize=(8, 6))
ax.plot(range(n_flips + 1), wealth_path, linewidth=2, color='steelblue', marker='o', 
        markersize=6, 
        markerfacecolor='steelblue',
        markeredgecolor='black')
ax.axhline(y=initial_balance, color='red', linestyle='--', linewidth=2, label='Initial Investment ($30,000)')
ax.set_xlabel('No of flips', fontsize=12)
ax.set_ylabel('Account Balance ($)', fontsize=12)
ax.set_title('Single Simulation Path: Account Balance Over Time', fontsize=14, fontweight='bold')
ax.legend(fontsize=10)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Print summary statistics
final_balance = wealth_path[-1]
print(f"Starting Age: 46")
print(f"Final Age: 75")
print(f"Number of flips: {n_flips}")
print(f"\nInitial balance: ${initial_balance:,}")
print(f"Final balance after {n_flips} flips: ${final_balance:,.2f}")
print(f"Total return: ${final_balance - initial_balance:,.2f} ({((final_balance/initial_balance) - 1)*100:.2f}%)")
print(f"Peak balance: ${np.max(wealth_path):,.2f}")
print(f"Minimum balance: ${np.min(wealth_path):,.2f}")
print(f"\nHeads (wins): {np.sum(wealth_path > initial_balance)} out of {n_flips} ({(np.sum(wealth_path > initial_balance) / n_flips)*100:.2f}%)")
print(f"Tails (losses): {np.sum(wealth_path < initial_balance)} out of {n_flips} ({(np.sum(wealth_path < initial_balance) / n_flips)*100:.2f}%)")
```

**Narrative:** This simulation (with seed=42 for reproducibility) reveals a path of significant volatility in the account balance. The strategy generates dramatic swings with each coin flip, where the account can experience both rapid gains and substantial drawdowns. This illustrates the inherent risk and substantial uncertainty of the investment, as the account value is highly sensitive to the outcome of each individual event. While the theoretical expected value of the strategy is positive over an infinite number of trials, the observed single path demonstrates the stark reality that individual outcomes can vary widely and that a favorable long-term average does not mitigate the risk of significant short-term losses. This highlights the crucial distinction between a strategy's expected value and the actual, high-variance results experienced in a finite number of simulations.

### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

# Run 100 simulations and plot histogram of final balances
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter, MultipleLocator

# Set seed for reproducibility
np.random.seed(42)

# Parameters
n_simulations = 100
n_flips = 29
initial_balance = 30000

# Function to run a single simulation
def run_simulation(initial_balance, n_flips):
    """Run a single simulation and return the final balance."""
    balance = initial_balance
    for t in range(n_flips):
        coin_flip = np.random.random()
        if coin_flip < 0.5:
            # Heads: increase by 50%
            balance = balance * 1.5
        else:
            # Tails: decrease by 40%
            balance = balance * 0.6
    return balance

# Run 100 simulations
final_balances = np.zeros(n_simulations)
for i in range(n_simulations):
    final_balances[i] = run_simulation(initial_balance, n_flips)

# Compute statistics
mean_final = np.mean(final_balances)
median_final = np.median(final_balances)
prob_above_initial = np.mean(final_balances > initial_balance)
prob_below_initial = np.mean(final_balances < initial_balance)

# Create histogram with log scale bins
fig, ax = plt.subplots(figsize=(10, 6))

# Create log-spaced bins
min_balance = np.min(final_balances)
max_balance = np.max(final_balances)
log_bins = np.logspace(np.log10(min_balance), np.log10(max_balance), 30)

# Split data into below and above initial balance
balances_below = final_balances[final_balances < initial_balance]
balances_above = final_balances[final_balances >= initial_balance]

# Plot histograms with different colors
ax.hist(balances_below, bins=log_bins, edgecolor='black', alpha=0.7, color='red', 
        label=f'Below ${initial_balance:,}')
ax.hist(balances_above, bins=log_bins, edgecolor='black', alpha=0.7, color='green', 
        label=f'Above ${initial_balance:,}')

ax.axvline(x=initial_balance, color='red', linestyle='--', linewidth=2, 
           label=f'Initial Investment (${initial_balance:,})')
ax.axvline(x=mean_final, color='green', linestyle='-', linewidth=2, 
           label=f'Mean (${mean_final:,.0f})')
ax.axvline(x=median_final, color='orange', linestyle=':', linewidth=2, 
           label=f'Median (${median_final:,.0f})')
ax.set_xscale('log')

# Format x-axis tick labels as dollar amounts
def dollar_formatter(x, pos):
    """Format tick labels as dollar amounts."""
    return f'${x:,.0f}'

ax.xaxis.set_major_formatter(FuncFormatter(dollar_formatter))

# Format y-axis tick labels as whole numbers
def int_formatter(x, pos):
    """Format tick labels as whole numbers."""
    return f'{int(x)}'

ax.yaxis.set_major_formatter(FuncFormatter(int_formatter))
ax.yaxis.set_major_locator(MultipleLocator(5))

ax.set_xlabel('Final Balance ($, log scale)', fontsize=12)
ax.set_ylabel('No of Simulations', fontsize=12)
ax.set_title('Distribution of Final Balances Across 100 Simulations (Log Scale)', 
             fontsize=14, fontweight='bold')
ax.legend(fontsize=10)
ax.grid(True, alpha=0.3, axis='y')
plt.tight_layout()
plt.show()

# Print statistics
print(f"Simulation Parameters:")
print(f"  --------------------------------")
print(f"  Initial balance: ${initial_balance:,}")
print(f"  Number of simulations: {n_simulations}")
print(f"  Time period: {n_flips} (ages 46-75)")
print(f"\nDistribution Statistics:")
print(f"  --------------------------------")
print(f"  Mean final balance: ${mean_final:,.2f}")
print(f"  Median final balance: ${median_final:,.2f}")
print(f"  standard deviation: ${np.std(final_balances):,.2f}")
print(f"  Minimum final balance: ${np.min(final_balances):,.2f}")
print(f"  Maximum final balance: ${np.max(final_balances):,.2f}")
print(f"\nProbability Statistics:")
print(f"  --------------------------------")
print(f"  Probability of final balance < ${initial_balance:,}: {prob_below_initial*100:.1f}%")
print(f"  Probability of final balance > ${initial_balance:,}: {prob_above_initial*100:.1f}%")

```

**Narrative:** After running 100 simulations of the game over 29 years:

**Distribution Characteristics:**

  - The distribution is heavily right-skewed.
  - Mean balance is $192,131.11 which is significantly higher than the median balance of $10,294.56.
  - Standard deviation is $1,561,309.44 which is very high.
  - This indicates extreme volatility in the outcomes: some simulations end up with very high balances, while others end up with very low balances or significant losses.
  - The wide range (from $16.87 to $15,708,246.77) demonstrates the extreme nature of the outcomes & high variance.

**Probability of Happy Outcomes:**

  - On investing $30,000, probability of ending with more than $30,000 is 19%.
  - This means in 19 out of 100 simulations would be considered a "happy outcome".

**Risk Assessment:**

  - Less than 20% of the simulations ended with a balance greater than $30,000. This is a significant risk, as it means that the investor has a 20% chance of losing money over the 29-year period.
  - The high standard deviation of $1,561,309.44 indicates that the outcomes are highly unpredictaable.
  - You could loose up to $15,708,246.77 if the outcomes are very unfavorable or gain up to $192,131.11 if the outcomes are very favorable.


**Conclusion:**

For an investor considering whether to buy into this game with $30,000, the simulation results suggest that:

  - The probability of losing money is significant
  - The range of possible outcomes is extreme
  - The typical (median) outcome may be disappointing despite positive expected value
  - The risk of catastrophic loss cannot be ignored

This analysis demonstrates why risk assessment must go beyond simple expected value calculations. The distribution characteristics, probability of favorable outcomes, and comprehensive risk assessment all point to the same conclusion: **this investment, while mathematically favorable in expectation, carries substantial risk that may be unacceptable for most investors, particularly those who cannot afford to lose their initial capital.**

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

TODO: Report the probability estimate and interpret its practical meaning.

```{python}
#| label: q4-prob-original-py
#| echo: false

# Using the 100 simulations above, estimate P(final > 30000)
import numpy as np

# The final_balances array from section 3 should be available
# If not, we'll recalculate (but it should be available from previous chunk)
initial_balance = 30000

# Estimate probability that final balance > $30,000
prob_above_30000 = np.mean(final_balances > initial_balance)

# Print numeric result as percentage
print(f"Probability estimate P(final > ${initial_balance:,}): {prob_above_30000*100:.1f}%")

```

**Interpretation:**


The probability estimate P(final > $30,000) = 19.0% reveals a critical insight about the investment game's risk profile. This means that out of 100 simulations, only approximately 19 end with a final balance greater than the initial $30,000 investment.


**Conclusion:**

The probability estimate of 19% for ending above the initial investment provides a clear, quantitative measure of the investment's risk. This low probability, combined with the extreme volatility and wide range of outcomes observed in the simulations, suggests that **this investment carries substantial risk that may be unacceptable for most investors**. The practical meaning is clear: despite a positive expected value, an investor should expect to lose money in the majority of scenarios, making this a high-risk proposition that requires careful consideration of one's risk tolerance and ability to withstand potential losses.

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 50% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Comparison of original and modified strategy distributions on the same plot"

# Implement the modified game where only 50% of balance is at risk each round
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter, MultipleLocator

# Set seed for reproducibility
np.random.seed(42)

# Parameters
n_simulations = 100
n_flips = 29
initial_balance = 30000
gamble_fraction = 0.50  # Only 50% of balance is gambled each round

# Function to run a single modified simulation
def run_modified_simulation(initial_balance, n_flips, gamble_fraction):
    """Run a single modified simulation where only a fraction of balance is at risk."""
    balance = initial_balance
    for t in range(n_flips):
        coin_flip = np.random.random()
        if coin_flip < 0.5:
            # Heads: gain 50% on the gambled portion
            # balance = balance + gamble_fraction * balance * 0.5
            balance = balance * (1 + gamble_fraction * 0.5)
        else:
            # Tails: lose 40% on the gambled portion
            # balance = balance - gamble_fraction * balance * 0.4
            balance = balance * (1 - gamble_fraction * 0.4)
    return balance

# Run 100 simulations for modified strategy
final_balances_modified = np.zeros(n_simulations)
for i in range(n_simulations):
    final_balances_modified[i] = run_modified_simulation(initial_balance, n_flips, gamble_fraction)

# Compute statistics for modified strategy
mean_modified = np.mean(final_balances_modified)
median_modified = np.median(final_balances_modified)
prob_above_initial_modified = np.mean(final_balances_modified > initial_balance)

# Create single plot with both distributions overlaid
fig, ax = plt.subplots(figsize=(8, 6))

# Create log-spaced bins for both plots
min_balance_orig = np.min(final_balances)
max_balance_orig = np.max(final_balances)
min_balance_mod = np.min(final_balances_modified)
max_balance_mod = np.max(final_balances_modified)
min_balance = min(min_balance_orig, min_balance_mod)
max_balance = max(max_balance_orig, max_balance_mod)
log_bins = np.logspace(np.log10(min_balance), np.log10(max_balance), 30)

# Plot Original Strategy
ax.hist(final_balances, bins=log_bins, edgecolor='darkblue', alpha=0.6, color='steelblue', 
        label='Original Strategy (Full Balance at Risk)', linewidth=1.5)

# Plot Modified Strategy
ax.hist(final_balances_modified, bins=log_bins, edgecolor='darkred', alpha=0.6, color='coral', 
        label='Modified Strategy (50% of Balance at Risk)', linewidth=1.5)

# Add vertical reference lines
ax.axvline(x=initial_balance, color='red', linestyle='--', linewidth=2, 
           label=f'Initial Investment (${initial_balance:,})', zorder=10)

# Add mean and median lines for Original Strategy
ax.axvline(x=mean_final, color='steelblue', linestyle='-', linewidth=2, 
           label=f'Original Mean (${mean_final:,.0f})', alpha=0.7)
ax.axvline(x=median_final, color='steelblue', linestyle=':', linewidth=2, 
           label=f'Original Median (${median_final:,.0f})', alpha=0.7)

# Add mean and median lines for Modified Strategy
ax.axvline(x=mean_modified, color='coral', linestyle='-', linewidth=2, 
           label=f'Modified Mean (${mean_modified:,.0f})', alpha=0.7)
ax.axvline(x=median_modified, color='coral', linestyle=':', linewidth=2, 
           label=f'Modified Median (${median_modified:,.0f})', alpha=0.7)

# Format axes
ax.set_xscale('log')
ax.set_xlabel('Final Balance ($, log scale)', fontsize=12)
ax.set_ylabel('No of Simulations', fontsize=12)
ax.set_title('Comparison: Original vs Modified Strategy Distributions', 
             fontsize=14, fontweight='bold')
ax.legend(fontsize=9, loc='upper left')
ax.grid(True, alpha=0.3, axis='y')
ax.xaxis.set_major_formatter(FuncFormatter(lambda x, p: f'${x:,.0f}'))
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, p: f'{int(x)}'))
ax.yaxis.set_major_locator(MultipleLocator(5))

plt.tight_layout()
plt.show()

# Print comparison statistics
print("=" * 60)
print("COMPARISON: Original vs Modified Strategy")
print("=" * 60)
print(f"\nOriginal Strategy (Full Balance at Risk):")
print(f"  Mean final balance: ${mean_final:,.2f}")
print(f"  Median final balance: ${median_final:,.2f}")
print(f"  Standard deviation: ${np.std(final_balances):,.2f}")
print(f"  P(final > ${initial_balance:,}): {prob_above_initial*100:.1f}%")
print(f"  Min: ${np.min(final_balances):,.2f}, Max: ${np.max(final_balances):,.2f}")

print(f"\nModified Strategy (50% of Balance at Risk):")
print(f"  Mean final balance: ${mean_modified:,.2f}")
print(f"  Median final balance: ${median_modified:,.2f}")
print(f"  Standard deviation: ${np.std(final_balances_modified):,.2f}")
print(f"  P(final > ${initial_balance:,}): {prob_above_initial_modified*100:.1f}%")
print(f"  Min: ${np.min(final_balances_modified):,.2f}, Max: ${np.max(final_balances_modified):,.2f}")

print(f"\nDifferences:")
print(f"  Mean difference: ${mean_modified - mean_final:,.2f}")
print(f"  Median difference: ${median_modified - median_final:,.2f}")
print(f"  Standard dev ratio (mod/orig): {np.std(final_balances_modified) / np.std(final_balances):.3f}")
print(f"  P(>${initial_balance:,}) difference: {(prob_above_initial_modified - prob_above_initial)*100:.1f}%")

```

**Interpretation:**

**Which strategy is riskier?**

The **original strategy (100% of balance at risk) is significantly riskier** than the modified strategy. This is evident from several key metrics:

1. **Standard Deviation**: The original strategy has a much higher standard deviation, indicating greater volatility and uncertainty in outcomes. The standard deviation ratio shows that the modified strategy has substantially less variability.

2. **Range of Outcomes**: The original strategy exhibits a wider spread between minimum and maximum final balances, demonstrating extreme outcomes in both directions. This creates a higher risk of substantial losses.

3. **Probability of Loss**: While both strategies have some probability of ending below the initial investment, the original strategy's higher volatility means it has a greater chance of experiencing severe drawdowns.

4. **Median vs Mean**: The larger gap between median and mean in the original strategy (compared to the modified strategy) indicates a right-skewed distribution with more extreme positive outliers, but also more potential for significant losses.

**Which has better upside?**

The **original strategy (100% of balance at risk) has better upside potential**, as evidenced by:

1. **Higher Maximum Values**: The original strategy achieves higher maximum final balances in the simulations, demonstrating its superior upside when favorable sequences of coin flips occur.

2. **Higher Mean**: The original strategy has a higher mean final balance, reflecting its greater expected value when all outcomes are considered.

3. **Compounding Effect**: By betting the full balance each round, the original strategy benefits more from compounding gains during winning streaks, leading to exponential growth in favorable scenarios.

**Trade-off Summary:**

The comparison reveals a classic risk-return trade-off:

  - **Original Strategy**: Higher risk (volatility) but better upside potential (higher maximums and mean)
  - **Modified Strategy**: Lower risk (reduced volatility) but more limited upside (lower maximums and mean)

The modified strategy provides a more balanced approach, reducing the risk of catastrophic losses while still maintaining positive expected returns, though with less extreme upside potential. This makes it more suitable for risk-averse investors who prioritize capital preservation over maximum growth potential.

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
What is the Kelly Criterion and how does it relate to the modified strategy?

```{python}
#| label: q6-kelly-criterion-py
#| echo: false

# Calculate the Kelly Criterion for this investment game
import numpy as np

# Game parameters
p = 0.5  # Probability of winning (heads)
win_multiplier = 1.5  # If heads: balance multiplies by 1.5
loss_multiplier = 0.6  # If tails: balance multiplies by 0.6

# For the Kelly Criterion, we model betting a fraction f of wealth each round
# If we bet fraction f of our wealth:
# - Win: W_new = W * (1 + 0.5*f)  [gain 50% on the fraction bet]
# - Loss: W_new = W * (1 - 0.4*f)  [lose 40% on the fraction bet]

# Parameters for Kelly formula:
b = 0.5  # Net gain fraction when winning (50% of fraction bet)
a = 0.4  # Net loss fraction when losing (40% of fraction bet)

# Kelly fraction formula (maximizes expected logarithmic growth)
# f* = (p*b - (1-p)*a) / (b*a)
# This is derived from maximizing E[log(W)] = p*log(1+b*f) + (1-p)*log(1-a*f)

kelly_fraction = (p * b - (1 - p) * a) / (b * a)

print("=" * 70)
print("KELLY CRITERION ANALYSIS")
print("=" * 70)
print(f"\nGame Parameters:")
print(f"  Probability of win (p): {p}")
print(f"  Probability of loss (q): {1-p}")
print(f"  Win multiplier: {win_multiplier}x (gain 50% on bet)")
print(f"  Loss multiplier: {loss_multiplier}x (lose 40% on bet)")
print(f"  Net gain on win (b): {b} (50% of fraction bet)")
print(f"  Net loss on loss (a): {a} (40% of fraction bet)")

print(f"\nKelly Criterion Formula:")
print(f"  f* = (p*b - (1-p)*a) / (b*a)")
print(f"  f* = ({p}*{b} - {1-p}*{a}) / ({b}*{a})")
print(f"  f* = ({p*b:.3f} - {(1-p)*a:.3f}) / {b*a:.3f}")
print(f"  f* = {p*b - (1-p)*a:.3f} / {b*a:.3f}")
print(f"  f* = {kelly_fraction:.3f} ({kelly_fraction*100:.1f}%)")

print(f"\nInterpretation:") 
print(f"  The optimal fraction to bet each round is {kelly_fraction*100:.1f}% of current wealth.")
print(f"  This maximizes the long-term logarithmic growth rate.")

print(f"\nComparison with Strategies:")
print(f"  Original Strategy: 100% of balance at risk (over-betting)")
print(f"  Modified Strategy: 50% of balance at risk (still over-betting)")
print(f"  Kelly Optimal: {kelly_fraction*100:.1f}% of balance at risk")

if kelly_fraction > 0:
    print(f"\n  âœ“ The game has positive expected value, so Kelly fraction is positive.")
    print(f"  âœ“ Both strategies (100% and 50%) bet more than the Kelly optimal.")
    print(f"  âœ“ Over-betting relative to Kelly increases volatility and risk of ruin.")
else:
    print(f"\n  âœ— Kelly fraction is negative - the game is not favorable long-term.")

print("\n" + "=" * 70)

```

**Explanation:**

The **Kelly Criterion** is a formula that determines the optimal fraction of wealth to bet in order to maximize long-term logarithmic growth rate. Developed by John L. Kelly Jr. in 1956, it balances the trade-off between growth potential and risk of ruin.

For this investment game, the Kelly Criterion suggests betting approximately **25%** of your current wealth each round (f* = 0.25). This is calculated based on:
- The probability of winning (50%)
- The gain when winning (50% on the fraction bet)
- The loss when losing (40% on the fraction bet)

**Key Findings:**

1. **Original Strategy (100% at risk)**: This represents severe over-betting relative to the Kelly optimal. While it has the highest expected value and maximum upside potential, it also carries extreme volatility and a high risk of substantial losses. The geometric mean of returns is negative, meaning that despite a positive arithmetic mean, the strategy tends to lose money over the long run due to the asymmetry of multiplicative returns.

2. **Modified Strategy (50% at risk)**: This strategy reduces risk compared to the original, but still over-bets relative to Kelly. It provides a better balance between growth and risk, with:
   - Lower volatility than the original strategy
   - Higher probability of ending above the initial investment
   - Better median outcomes
   - Reduced risk of extreme losses

3. **Kelly Optimal (25% at risk)**: Betting the Kelly fraction would theoretically maximize long-term growth while minimizing the risk of ruin. It balances the trade-off between:
   - Growth potential (higher expected logarithmic return)
   - Risk management (lower probability of catastrophic losses)
   - Volatility reduction (more stable outcomes)

**Practical Implications:**

The comparison between the original and modified strategies illustrates a fundamental principle: **over-betting relative to Kelly increases both volatility and the risk of ruin, even when the expected value is positive**. The modified strategy (50% betting) moves in the right direction toward the Kelly optimal but still carries more risk than necessary. 

This analysis highlights why expected value alone is insufficient for decision-making in multiplicative (compounding) scenarios. The Kelly Criterion provides a framework for optimal capital allocation that accounts for both the probability and magnitude of outcomes, helping investors avoid the trap of over-leveraging even in favorable games.


## Professional Presentation (From Grading TLDR)

- **Clear narrative:** tell the story succinctly (aim for a 1â€“5 minute read)
- **Focus on insights:** risk profiles, counter-intuitive results, practical implications
- **Professional style:** concise writing, clean visuals, hide code where appropriate (`echo: false`)
- **Human interpretation:** explain what results mean for real decisions

## Submission Checklist âœ…

- [ ] Quarto document written with narrative and results
- [ ] Rendered to HTML successfully
- [ ] Repository `simulationChallenge` created on GitHub
- [ ] HTML committed and pushed
- [ ] GitHub Pages enabled (Deploy from a branch â†’ main â†’ /(root))
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

## Tips

- Set random seeds for reproducibility
- Use object-oriented plotting with `matplotlib`
- Keep figures readable and labeled; prefer professional styling
- Commit early and often; render locally before pushing

