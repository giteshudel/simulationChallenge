x---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

:::: {.callout-important}
## ðŸ“‹ What You Need To Do

- [ ] Fork and create repo `simulationChallenge` in your GitHub
- [ ] Clone locally and open in Cursor
- [ ] Write your analysis in this `index.qmd`
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/simulationChallenge/`
:::

:::: {.callout-warning}
## âš ï¸ AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain the results in your own words.  Verify cursor's calculations as investment simulation is tricky.
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

::::: {.callout-note}
## Grading Scope

- Sections 1â€“4: required and can earn up to 90% of the grade.
- Sections 5â€“6: optional; strong, well-supported work here can bring your score up to 100%.
::::

### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is >, =, or < $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?

```{python}
#| label: q1-expected-value-py
#| echo: true

# Compute EV after one flip in Python
# After one flip:
# - Heads (50% chance): W1 = 30,000 * 1.5 = $45,000
# - Tails (50% chance): W1 = 30,000 * 0.6 = $18,000
# EV = 0.5 * 45,000 + 0.5 * 18,000

initial_balance = 30000
heads_multiplier = 1.5
tails_multiplier = 0.6
prob_heads = 0.5

wealth_heads = initial_balance * heads_multiplier
wealth_tails = initial_balance * tails_multiplier
expected_value = (prob_heads * wealth_heads) + (prob_heads * wealth_tails)

print(f"Initial wealth: ${initial_balance:,}")
print(f"After heads (50%): ${wealth_heads:,}")
print(f"After tails (50%): ${wealth_tails:,}")
print(f"\nExpected value after one flip: ${expected_value:,.2f}")
print(f"Gain in EV: ${expected_value - initial_balance:,.2f}")
print(f"Percentage gain: {((expected_value - initial_balance) / initial_balance) * 100:.2f}%")
```

**Interpretation:** The expected value after one flip is **$31,500**, which is **5% higher** than the initial buy-in of $30,000. This simple expected value calculation suggests the game has a positive expected return, which is favorable for the investor.

### 2) Single Simulation Over Time (Narrative + Plot)

Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.

```{python}
#| label: q2-single-sim-py
#| echo: true
#| fig-cap: "Single simulation path of account balance"

# Simulate one path from $30,000 over N periods
import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Assuming starting at age 46, playing until age 75 (75-46) = 29 flips
n_flips = 29
initial_balance = 30000

# Initialize array to store wealth over time
wealth_path = np.zeros(n_flips + 1)
wealth_path[0] = initial_balance

# Simulate the coin flips and compute wealth at each step
for t in range(1, n_flips + 1):
    coin_flip = np.random.random()  # Generate random number in [0, 1)
    if coin_flip < 0.5:
        # Heads: increase by 50%
        wealth_path[t] = wealth_path[t-1] * 1.5
    else:
        # Tails: decrease by 40%
        wealth_path[t] = wealth_path[t-1] * 0.6

# Create time series plot using object-oriented matplotlib
fig, ax = plt.subplots(figsize=(8, 6))
ax.plot(range(n_flips + 1), wealth_path, linewidth=2, color='steelblue')
ax.axhline(y=initial_balance, color='red', linestyle='--', linewidth=2, label='Initial Investment ($30,000)')
ax.set_xlabel('No of flips', fontsize=12)
ax.set_ylabel('Account Balance ($)', fontsize=12)
ax.set_title('Single Simulation Path: Account Balance Over Time', fontsize=14, fontweight='bold')
ax.legend(fontsize=10)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Print summary statistics
final_balance = wealth_path[-1]
print(f"Initial balance: ${initial_balance:,}")
print(f"Final balance after {n_flips} flips: ${final_balance:,.2f}")
print(f"Total return: ${final_balance - initial_balance:,.2f} ({((final_balance/initial_balance) - 1)*100:.2f}%)")
print(f"Peak balance: ${np.max(wealth_path):,.2f}")
print(f"Minimum balance: ${np.min(wealth_path):,.2f}")
```

**Narrative:** This simulation (with seed=42 for reproducibility) reveals a path of significant volatility in the account balance. The strategy generates dramatic swings with each coin flip, where the account can experience both rapid gains and substantial drawdowns. This illustrates the inherent risk and substantial uncertainty of the investment, as the account value is highly sensitive to the outcome of each individual event. While the theoretical expected value of the strategy is positive over an infinite number of trials, the observed single path demonstrates the stark reality that individual outcomes can vary widely and that a favorable long-term average does not mitigate the risk of significant short-term losses. This highlights the crucial distinction between a strategy's expected value and the actual, high-variance results experienced in a finite number of simulations.

### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?

```{python}
#| label: q3-dist-100-py
#| echo: true
#| fig-cap: "Distribution of final balances across 100 simulations"

# TODO: Run 100 simulations and plot histogram of final balances
# - Add vertical line at $30,000
# - Compute mean, median, and P(final > $30,000)

```

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

TODO: Report the probability estimate and interpret its practical meaning.

```{python}
#| label: q4-prob-original-py
#| echo: true

# TODO: Using the 100 simulations above, estimate P(final > 30000)
# - Print numeric result with 3 decimals

```

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

```{python}
#| label: q5-modified-50pct-py
#| echo: true
#| fig-cap: "Modified strategy distribution (bet 50% each round)"

# TODO: Implement the modified game
# - Run 100 simulations; plot distribution of final balances
# - Estimate P(final > 30000) and compare to original
# - visually compare the outcome distributions of the original and modified strategies

```

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
What is the Kelly Criterion and how does it relate to the modified strategy?


## Professional Presentation (From Grading TLDR)

- **Clear narrative:** tell the story succinctly (aim for a 1â€“5 minute read)
- **Focus on insights:** risk profiles, counter-intuitive results, practical implications
- **Professional style:** concise writing, clean visuals, hide code where appropriate (`echo: false`)
- **Human interpretation:** explain what results mean for real decisions

## Submission Checklist âœ…

- [ ] Quarto document written with narrative and results
- [ ] Rendered to HTML successfully
- [ ] Repository `simulationChallenge` created on GitHub
- [ ] HTML committed and pushed
- [ ] GitHub Pages enabled (Deploy from a branch â†’ main â†’ /(root))
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

## Tips

- Set random seeds for reproducibility
- Use object-oriented plotting with `matplotlib`
- Keep figures readable and labeled; prefer professional styling
- Commit early and often; render locally before pushing

